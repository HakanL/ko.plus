{"name":"ko.plus","tagline":"Awesome extensions to KnockoutJS","body":"ï»¿# ko.plus\r\n\r\nko.plus is a collection of extensions to [KnockoutJs](http://knockoutjs.com/) that add to the core library.\r\n\r\n## Installation\r\nGet the ko.plus package [from NuGet](http://www.nuget.org/packages/ko.plus).\r\n\r\n    Install-Package ko.plus\r\n\r\n## ko.command\r\n\r\nko.command creates a representation of a command that exposes `isRunning`, `failed` and other observable properties to allow binding to command state.\r\n\r\nThe created commands can be invoked directly (as you would a normal function) and as such can be bound to the `click` handler.\r\nThey support both sychronous and asynchronous implementation code, and expose `done`, `fail` and `always` methods to allow continuations.\r\n\r\n### Example Implementation\r\n\r\n    function ViewModel() {\r\n        this.doSomething = ko.command(function() {\r\n            return $.get(\"...\");\r\n        })\r\n        .done(function(data) {\r\n            //do something with the response\r\n        })\r\n        .fail(function(error) {\r\n            //handle the error\r\n        });\r\n    }\r\n\r\nThe state properties can be bound in the UI:\r\n\r\n    <span data-bind=\"visible: doSomething.isRunning\">Loading...</span>\r\n    <span data-bind=\"visible: doSomething.failed\">Something went wrong!</span>\r\n\r\n### Options\r\n\r\n#### action\r\nThe action function can be specified as the single parameter passed to `ko.command` or as the `action` property on an options object passed into the function.\r\n\r\n    ko.command(function() { /*...*/ });\r\n    //or\r\n    ko.command({\r\n        action: function() { /*...*/ })\r\n    });\r\n\r\n#### canExecute\r\nAn optional `canExecute` function can be specified to determine whether or not a command can currently be executed.\r\n\r\n    function ViewModel() {\r\n        this.doSomething = ko.command({\r\n            action: function() {\r\n                return $.get(\"...\");\r\n            },\r\n            canExecute: function() {\r\n                //validation logic\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\nNote: the function passed as `canExecute` will be wrapped in a `ko.computed`, so if it uses other observable properties it will automatically be updated.\r\nIf you need to manually inform a command that the value of `canExecute` has changed then you can call the `canExecuteHasMutated` function, which will force a reevaluation.\r\n\r\n#### context\r\nThe `context` option sets the context in which the callbacks and action functions will be executed.\r\n\r\n    function ViewModel() {\r\n        this.url = \"...\";\r\n\r\n        this.doSomething = ko.command({\r\n            action: function() {\r\n                return $.get(this.url);\r\n            },\r\n            context: this\r\n        });\r\n    }\r\n\r\n### Properties\r\n\r\n#### isRunning\r\nAn observable that indicates whether or not the command is currently running.\r\n\r\n#### canExecute\r\nA computed observable that indicates whether or not the command is currently able to execute.\r\n\r\n#### failed\r\nAn observable that indicates whether or not the last invocation of the command failed.\r\n\r\n### Functions\r\n\r\n#### done\r\nAttach a callback that will be invoked when the command completes successfully.\r\n\r\n#### fail\r\nAttach a callback that will be invoked when the command fails.\r\n\r\n#### always\r\nAttach a callback that will be invoked when the command either completes successfully or fails.\r\n\r\n### Further Reading\r\n\r\n* [Introductory Blog Post](http://blog.greatrexpectations.com/2012/06/26/command-pattern-with-jquery-deferred-knockout/)\r\n* [Updated Blog Post](http://blog.greatrexpectations.com/2012/07/12/command-pattern-v2-using-knockout/)\r\n* [Handling Context](http://blog.greatrexpectations.com/2013/07/29/handling-this-in-ko-command/)\r\n\r\n## ko.editable & ko.editableArray\r\n\r\nko.editable creates an extendion of `ko.observable` with some additional properties to aid in beginning, cancelling and committing changes.\r\nko.editableArray does the same for instances of `ko.observableArray`.\r\n\r\n### Example Implementation\r\n\r\n    function ViewModel() {\r\n       this.value = ko.editable(123);\r\n    }\r\n\r\n    var instance = new ViewModel();\r\n    //instance.value -> 123\r\n\r\n    instance.value.beginEdit();\r\n    instance.value(456);\r\n    //instance.value -> 456\r\n\r\n    instance.value.cancelEdit();\r\n    //instance.value -> 123\r\n\r\n### Properties\r\n\r\n#### isEditing\r\nAn observable property that indicates whether or not the editable is currently in edit mode.\r\n\r\n### Functions\r\n\r\n#### beginEdit\r\nPuts the editable into edit mode.\r\n\r\n#### endEdit\r\nTakes the editable out of edit mode, commiting any changes.\r\n\r\n#### cancelEdit\r\nTakes the editable out of edit mode and reverts to value at the point when `beginEdit` was called.\r\n\r\n#### rollback\r\nWithout changing edit state, reverts back through historically committed values for this editable until it reaches the original value.\r\n\r\n### Further Reading\r\n\r\n*  [Introductory Blog Post](http://blog.greatrexpectations.com/2012/09/20/editable-fields-with-cancelability-in-knockout/)\r\n\r\n## ko.makeEditable\r\n\r\nko.makeEditable adds to the functionality of `ko.editable` and `ko.editableArray` (which only apply to single properties) and expands to allow object graphs to be editable.\r\n\r\nThis works by appending `beginEdit`, `cancelEdit`, `endEdit` and `rollback` methods to the target object that will visit all child properties and, if they are editable, invoke the appropriate function.\r\n\r\nThe function will be applied recursively to:\r\n\r\n *  immediate child properties that are editable (whether instances of `ko.editable` or other editable view models)\r\n *  any editable objects found in child arrays (either editable arrays or normal)\r\n\r\n### Example Implementation\r\n\r\n    function ViewModel() {\r\n        this.property1 = ko.editable();\r\n        this.property2 = ko.editable();\r\n        this.arrayProperty = ko.editableArray([\r\n            ko.editable(),\r\n            ko.editable()\r\n        ]);\r\n\r\n        ko.makeEditable(this);\r\n    }\r\n\r\n    var instance = new ViewModel();\r\n    instance.beginEdit();\r\n    \r\n    instance.property1.isEditing(); // -> true\r\n    instance.property2.isEditing(); // -> true\r\n    instance.property1.isEditing(); // -> true\r\n\r\n### Properties\r\n\r\n#### isEditing\r\nAn observable property that indicates whether or not the editable is currently in edit mode.\r\n\r\n### Functions\r\n\r\n#### beginEdit\r\nPuts the editable and all child editables into edit mode.\r\n\r\n#### endEdit\r\nTakes the editable and all child editables out of edit mode, commiting any changes.\r\n\r\n#### cancelEdit\r\nTakes the editable and all child editables out of edit mode and reverts to value at the point when `beginEdit` was called.\r\n\r\n#### rollback\r\nWithout changing edit state, reverts back through historically committed values for this editable until it reaches the original value for all child editables.\r\n\r\n### Further Reading\r\n\r\n*  [Introductory Blog Post](http://blog.greatrexpectations.com/2013/05/29/editable-object-graphs-in-knockout/)\r\n\r\n## ko.bindingHandlers.loadingWhen\r\n\r\nThe `loadingWhen` custom binding handler replaces the contents of a container element with a loading placeholder when the bound value is truthy.\r\n\r\n### Example Implementation\r\n\r\n    <div data-bind=\"loadingWhen: someAction.isRunning\">\r\n\t\t<p>This will content will be replaced when someAction.isRunning</p>\r\n\t</div>\r\n\r\n### Options\r\n\r\n#### loaderClass\r\nThe loading element is automatically assigned the `.loader` class (defined in `ko.plus.css`).  \r\nThe `loaderClass` property specifies what additional class will be assigned to the loading element that sets the loading spinner.\r\n\r\nThe default option is `loader-dark` (grey spinner on a transparent background), and the default `ko.plus.css` stylesheet contains a `loader-white` option (white spinner on a transparent background).\r\n\r\nNon-default loader classes can also be assigned.\r\n\r\n### Notes\r\nWhilst primarily designed for container elements (`div`, `ul`, etc.) the `loadingWhen` binding will also work with elements that directly contain text (`button`, `a`, etc.).\r\n\r\nBy default the loading spinner will overlay itself over the text in these scenarios.  For a slightly better appearance, try setting a specific background colour on the element to \"hide\" the text content.  For example, if you have `a` elements on a white background you could use the following:\r\n\r\n    /* CSS */\r\n\ta > .loader { background-color: white; }\r\n\r\n\t<!-- HTML -->\r\n\t<body>\r\n\t\t<!-- \"Click Me\" will be hidden by the white background whilst command is running -->\r\n\t\t<a href=\"#\" data-bind=\"click: command, loadingWhen: command.isRunning\">Click Me</a>\r\n\t</body>\r\n\r\nImportant note: **don't** change the `background-image` - this is needed to display the loading spinner.\r\n\r\n### Further Reading\r\n\r\n*  [Introductory Blog post](http://blog.greatrexpectations.com/2012/06/17/loading-placeholders-using-knockout-js/)\r\n\r\n## ko.bindingHandlers.command\r\n\r\nThe `command` custom binding handler applies the following bindings for a `ko.command` instance specified through the `valueAccessor`:\r\n*  `click` bound to the command\r\n*  `loadingWhen` bound to `command.isRunning`\r\n*  `enable` bound to `command.canExecute`\r\n\r\n### Example Implementation\r\n\r\n    <button data-bind=\"command: someAction\">Do Something</button>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}